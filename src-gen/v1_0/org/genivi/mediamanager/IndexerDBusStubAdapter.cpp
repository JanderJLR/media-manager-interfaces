/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.3.v201507280808.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include <v1_0/org/genivi/mediamanager/Indexer.hpp>
#include <v1_0/org/genivi/mediamanager/IndexerDBusStubAdapter.hpp>

namespace v1_0 {
namespace org {
namespace genivi {
namespace mediamanager {

std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createIndexerDBusStubAdapter(
                   const CommonAPI::DBus::DBusAddress &_address,
                   const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection,
                   const std::shared_ptr<CommonAPI::StubBase> &_stub) {
    return std::make_shared<IndexerDBusStubAdapter>(_address, _connection, _stub);
}

INITIALIZER(registerIndexerDBusStubAdapter) {
    CommonAPI::DBus::Factory::get()->registerStubAdapterCreateMethod(
    	Indexer::getInterface(), &createIndexerDBusStubAdapter);
}

IndexerDBusStubAdapterInternal::~IndexerDBusStubAdapterInternal() {
    deactivateManagedInstances();
    IndexerDBusStubAdapterHelper::deinit();
}

void IndexerDBusStubAdapterInternal::deactivateManagedInstances() {

}

const char* IndexerDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
    static const std::string introspectionData =
        "<method name=\"getInterfaceVersion\">\n"
            "<arg name=\"value\" type=\"uu\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"getIndexerStatusAttribute\">\n"
            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onIndexerStatusAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"i\" />\n"
        "</signal>\n"
        /**
         * description: Get the path to the database file in the host file system.
                            
         *    This is the database file used by LMS to store metadata
         * param: output: Path to database file in host file system
         * deprecated: This is only used for testing purposes and will be removed
         */
        "<method name=\"getDatabasePath\">\n"
            "<arg name=\"_output\" type=\"s\" direction=\"out\" />\n"
            "<arg name=\"_e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: If the indexer is currently IDLE or RUNNING
                              (see
         *   IndexerStatus), stop indexing and set IndexerStatus
                              to
         *   STOPPED.
                              If indexer is currently STOPPED, no action is
         *   taken
         */
        "<method name=\"stopIndexing\">\n"
            "<arg name=\"_e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: If indexer is currently STOPPED (see IndexerStatus),
                             
         *   status is changed to RUNNING and indexing is RUNNING. If
                             
         *   the status is IDLE or RUNNING, no action is taken.
                              Note
         *   that the status may go from RUNNING to IDLE directly
                             
         *   after issuing this call, if no files are to be indexed
         */
        "<method name=\"startIndexing\">\n"
            "<arg name=\"_e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"

    ;
    return introspectionData.c_str();
}

CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::IndexerStub,
        CommonAPI::Version
        > IndexerDBusStubAdapterInternal::getIndexerInterfaceVersionStubDispatcher(&IndexerStub::getInterfaceVersion, "uu");

/**
 * description: Get the current status of the indexer.
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::IndexerStub,
        ::v1_0::org::genivi::mediamanager::Indexer::IndexerStatus
        > IndexerDBusStubAdapterInternal::getIndexerStatusAttributeStubDispatcher(
            &::v1_0::org::genivi::mediamanager::IndexerStub::getIndexerStatusAttribute
            , "i"
            );



/**
 * description: Get the path to the database file in the host file system.
                    
 *    This is the database file used by LMS to store metadata
 * param: output: Path to database file in host file system
 * deprecated: This is only used for testing purposes and will be removed
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1_0::org::genivi::mediamanager::IndexerStub,
    std::tuple<>,
    std::tuple<std::string, Indexer::IndexerError>,
    std::tuple<>,
    std::tuple<CommonAPI::DBus::StringDeployment, CommonAPI::EmptyDeployment>
    
    > IndexerDBusStubAdapterInternal::getDatabasePathStubDispatcher(
    &IndexerStub::getDatabasePath, "si",
					std::make_tuple(),
                	std::make_tuple(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: If the indexer is currently IDLE or RUNNING
                      (see
 *   IndexerStatus), stop indexing and set IndexerStatus
                      to
 *   STOPPED.
                      If indexer is currently STOPPED, no action is
 *   taken
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1_0::org::genivi::mediamanager::IndexerStub,
    std::tuple<>,
    std::tuple<Indexer::IndexerError>,
    std::tuple<>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > IndexerDBusStubAdapterInternal::stopIndexingStubDispatcher(
    &IndexerStub::stopIndexing, "i",
					std::make_tuple(),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: If indexer is currently STOPPED (see IndexerStatus),
                     
 *   status is changed to RUNNING and indexing is RUNNING. If
                     
 *   the status is IDLE or RUNNING, no action is taken.
                      Note
 *   that the status may go from RUNNING to IDLE directly
                     
 *   after issuing this call, if no files are to be indexed
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1_0::org::genivi::mediamanager::IndexerStub,
    std::tuple<>,
    std::tuple<Indexer::IndexerError>,
    std::tuple<>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > IndexerDBusStubAdapterInternal::startIndexingStubDispatcher(
    &IndexerStub::startIndexing, "i",
					std::make_tuple(),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));


/**
 * description: Get the current status of the indexer.
 */
void IndexerDBusStubAdapterInternal::fireIndexerStatusAttributeChanged(const ::v1_0::org::genivi::mediamanager::Indexer::IndexerStatus& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    ::v1_0::org::genivi::mediamanager::Indexer::IndexerStatus
    >>
        ::sendSignal(
            *this,
            "onIndexerStatusAttributeChanged",
            "i",
            value
    
    );
}



const IndexerDBusStubAdapterHelper::StubDispatcherTable& IndexerDBusStubAdapterInternal::getStubDispatcherTable() {
    return stubDispatcherTable_;
}

const CommonAPI::DBus::StubAttributeTable& IndexerDBusStubAdapterInternal::getStubAttributeTable() {
    return stubAttributeTable_;
}

IndexerDBusStubAdapterInternal::IndexerDBusStubAdapterInternal(
        const CommonAPI::DBus::DBusAddress &_address,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection,
        const std::shared_ptr<CommonAPI::StubBase> &_stub)
	: CommonAPI::DBus::DBusStubAdapter(_address, _connection,false),
      IndexerDBusStubAdapterHelper(_address, _connection, std::dynamic_pointer_cast<IndexerStub>(_stub), false),
      stubDispatcherTable_({
            /**
             * description: Get the current status of the indexer.
             */
            { { "getIndexerStatusAttribute", "" }, &org::genivi::mediamanager::IndexerDBusStubAdapterInternal::getIndexerStatusAttributeStubDispatcher }
            ,
            /**
             * description: Get the path to the database file in the host file system.
                                
             *    This is the database file used by LMS to store metadata
             * param: output: Path to database file in host file system
             * deprecated: This is only used for testing purposes and will be removed
             */
            { { "getDatabasePath", "" }, &org::genivi::mediamanager::IndexerDBusStubAdapterInternal::getDatabasePathStubDispatcher },
            /**
             * description: If the indexer is currently IDLE or RUNNING
                                  (see
             *   IndexerStatus), stop indexing and set IndexerStatus
                                  to
             *   STOPPED.
                                  If indexer is currently STOPPED, no action is
             *   taken
             */
            { { "stopIndexing", "" }, &org::genivi::mediamanager::IndexerDBusStubAdapterInternal::stopIndexingStubDispatcher },
            /**
             * description: If indexer is currently STOPPED (see IndexerStatus),
                                 
             *   status is changed to RUNNING and indexing is RUNNING. If
                                 
             *   the status is IDLE or RUNNING, no action is taken.
                                  Note
             *   that the status may go from RUNNING to IDLE directly
                                 
             *   after issuing this call, if no files are to be indexed
             */
            { { "startIndexing", "" }, &org::genivi::mediamanager::IndexerDBusStubAdapterInternal::startIndexingStubDispatcher }
            }),
        stubAttributeTable_() {

    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::mediamanager::IndexerDBusStubAdapterInternal::getIndexerInterfaceVersionStubDispatcher });
}

const bool IndexerDBusStubAdapterInternal::hasFreedesktopProperties() {
    return false;
}

} // namespace mediamanager
} // namespace genivi
} // namespace org
} // namespace v1_0
