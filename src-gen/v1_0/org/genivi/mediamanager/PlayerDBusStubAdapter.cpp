/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.3.v201507280808.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include <v1_0/org/genivi/mediamanager/Player.hpp>
#include <v1_0/org/genivi/mediamanager/PlayerDBusStubAdapter.hpp>

namespace v1_0 {
namespace org {
namespace genivi {
namespace mediamanager {

std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createPlayerDBusStubAdapter(
                   const CommonAPI::DBus::DBusAddress &_address,
                   const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection,
                   const std::shared_ptr<CommonAPI::StubBase> &_stub) {
    return std::make_shared<PlayerDBusStubAdapter>(_address, _connection, _stub);
}

INITIALIZER(registerPlayerDBusStubAdapter) {
    CommonAPI::DBus::Factory::get()->registerStubAdapterCreateMethod(
    	Player::getInterface(), &createPlayerDBusStubAdapter);
}

PlayerDBusStubAdapterInternal::~PlayerDBusStubAdapterInternal() {
    deactivateManagedInstances();
    PlayerDBusStubAdapterHelper::deinit();
}

void PlayerDBusStubAdapterInternal::deactivateManagedInstances() {

}

const char* PlayerDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
    static const std::string introspectionData =
        "<method name=\"getInterfaceVersion\">\n"
            "<arg name=\"value\" type=\"uu\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"getMuteAttribute\">\n"
            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"setMuteAttribute\">\n"
            "<arg name=\"requestedValue\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"setValue\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        "<signal name=\"onMuteAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"i\" />\n"
        "</signal>\n"
        "<method name=\"getShuffleAttribute\">\n"
            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"setShuffleAttribute\">\n"
            "<arg name=\"requestedValue\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"setValue\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        "<signal name=\"onShuffleAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"i\" />\n"
        "</signal>\n"
        "<method name=\"getRepeatAttribute\">\n"
            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"setRepeatAttribute\">\n"
            "<arg name=\"requestedValue\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"setValue\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        "<signal name=\"onRepeatAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"i\" />\n"
        "</signal>\n"
        "<method name=\"getRateAttribute\">\n"
            "<arg name=\"value\" type=\"d\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"setRateAttribute\">\n"
            "<arg name=\"requestedValue\" type=\"d\" direction=\"in\" />\n"
            "<arg name=\"setValue\" type=\"d\" direction=\"out\" />\n"
        "</method>\n"
        "<signal name=\"onRateAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"d\" />\n"
        "</signal>\n"
        "<method name=\"getVolumeAttribute\">\n"
            "<arg name=\"value\" type=\"d\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"setVolumeAttribute\">\n"
            "<arg name=\"requestedValue\" type=\"d\" direction=\"in\" />\n"
            "<arg name=\"setValue\" type=\"d\" direction=\"out\" />\n"
        "</method>\n"
        "<signal name=\"onVolumeAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"d\" />\n"
        "</signal>\n"
        "<method name=\"getCanGoNextAttribute\">\n"
            "<arg name=\"value\" type=\"b\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCanGoNextAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"b\" />\n"
        "</signal>\n"
        "<method name=\"getCanGoPreviousAttribute\">\n"
            "<arg name=\"value\" type=\"b\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCanGoPreviousAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"b\" />\n"
        "</signal>\n"
        "<method name=\"getCanPauseAttribute\">\n"
            "<arg name=\"value\" type=\"b\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCanPauseAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"b\" />\n"
        "</signal>\n"
        "<method name=\"getCanPlayAttribute\">\n"
            "<arg name=\"value\" type=\"b\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCanPlayAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"b\" />\n"
        "</signal>\n"
        "<method name=\"getCanSeekAttribute\">\n"
            "<arg name=\"value\" type=\"b\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCanSeekAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"b\" />\n"
        "</signal>\n"
        "<method name=\"getCurrentTrackAttribute\">\n"
            "<arg name=\"value\" type=\"t\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onCurrentTrackAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"t\" />\n"
        "</signal>\n"
        "<method name=\"getPlaybackStatusAttribute\">\n"
            "<arg name=\"value\" type=\"i\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onPlaybackStatusAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"i\" />\n"
        "</signal>\n"
        "<method name=\"getPositionAttribute\">\n"
            "<arg name=\"value\" type=\"t\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"getDurationAttribute\">\n"
            "<arg name=\"value\" type=\"t\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onDurationAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"t\" />\n"
        "</signal>\n"
        /**
         * description: Skip to the next track in the play queue. If there is no
                              
         *   next track, playback is stopped. If playback is paused or
                            
         *     stopped, this function will set the next plack to be
                              
         *   played once playback is activated
         */
        "<method name=\"next\">\n"
            "<arg name=\"_e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Open the supplied Uri for playback in the playback engine.
                 returns:
         *   INVALID_URI When an invalid URI is supplied
                                      
         *   (decided by playback engine)
                           NO_ERROR    On success
         * param: uri URI of media to play, uri format is decided by backend
         */
        "<method name=\"openUri\">\n"
            "<arg name=\"_uri\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"_e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Enqueue the supplied Uri for playback in the playback engine.
                 returns:
         *   INVALID_URI When an invalid URI is supplied
                                      
         *   (decided by playback engine)
                          NO_ERROR    On success
         * param: uri URI of media to enqueue, uri format is decided by backend
         */
        "<method name=\"enqueueUri\">\n"
            "<arg name=\"_uri\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"_e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Dequeue the item with the supplied index in the playback
                             
         *   engine.
         * param: pos index of media to dequeue
         */
        "<method name=\"dequeueIndex\">\n"
            "<arg name=\"_pos\" type=\"t\" direction=\"in\" />\n"
            "<arg name=\"_e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Retrieve the current play queue. The format of the result
                             
         *   object is described in MediaTypes.fidl
                 returns: Current play queue
         */
        "<method name=\"getCurrentPlayQueue\">\n"
            "<arg name=\"_playQueue\" type=\"aa{s(yv)}\" direction=\"out\" />\n"
            "<arg name=\"_e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Dequeue all elements, emptying the play queue
         */
        "<method name=\"dequeueAll\">\n"
            "<arg name=\"_e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Use the supplied playlist as the current play queue. If
                             
         *   the play queue is invalid, the old play queue is
                             
         *   untouched.
                 returns: BAD_PLAYLIST If playlist can not be loaded
              
         *               NO_ERROR     On success
         */
        "<method name=\"openPlaylist\">\n"
            "<arg name=\"_uri\" type=\"s\" direction=\"in\" />\n"
            "<arg name=\"_e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Pause playback in the playback engine.
                               If already
         *   paused, this has no effect
                               Note: If CanPause is false,
         *   this has no effect
         */
        "<method name=\"pause\">\n"
            "<arg name=\"_e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Start or resume playback in the playback engine.
                               If
         *   playback is already commencing, this has not effect.
                               If
         *   paused, playback resumes from the current position.
                               If
         *   there is no track to play, calling this has no effect
                              
         *   Note: If CanPlay is false, this has no effect
         */
        "<method name=\"play\">\n"
            "<arg name=\"_e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Starts playback (see Play) if paused
                              Pauses playback (see
         *   Pause) is playing
         * see: Play
         * see: Pause
         */
        "<method name=\"playPause\">\n"
            "<arg name=\"_e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Loads previous track in play queue
                              If there is no
         *   previous track, playback is stopped
                              If playback is
         *   stopped or paused, it remains this way,
                              but the next
         *   track to be played will the set
                              by this function
               
         *                 Note: If CanGoPrevious is false, this has no effect
         */
        "<method name=\"previous\">\n"
            "<arg name=\"_e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Seek relatively in the current track
                              If a negative seek
         *   leads to a play position less than 0,
                              the play position
         *   will be set to 0.
                              If a positive seek leads outside the
         *   length of the current
                              track, this is treated like a call
         *   to Next()
                              Note: If CanSeek is false, this has no effect
         * param: pos Relative seek amount in microseconds
         * see: Next
         */
        "<method name=\"seek\">\n"
            "<arg name=\"_pos\" type=\"x\" direction=\"in\" />\n"
            "<arg name=\"_e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Jump to the specified position in the current
                               If the
         *   position is not within range of the current track,
                               do
         *   nothing
                 Note: If CanSeek is false, this has no effect
         * param: pos Absolute position in microseconds
         */
        "<method name=\"setPosition\">\n"
            "<arg name=\"_pos\" type=\"t\" direction=\"in\" />\n"
            "<arg name=\"_e\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"

    ;
    return introspectionData.c_str();
}

CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        CommonAPI::Version
        > PlayerDBusStubAdapterInternal::getPlayerInterfaceVersionStubDispatcher(&PlayerStub::getInterfaceVersion, "uu");

/**
 * description: Mute or unmute audio. When muted, the player backend will
                     
 *   not produce any audio output.
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        ::v1_0::org::genivi::mediamanager::PlayerTypes::MuteStatus
        > PlayerDBusStubAdapterInternal::getMuteAttributeStubDispatcher(
            &::v1_0::org::genivi::mediamanager::PlayerStub::getMuteAttribute
            , "i"
            );
CommonAPI::DBus::DBusSetObservableAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        ::v1_0::org::genivi::mediamanager::PlayerTypes::MuteStatus
        > PlayerDBusStubAdapterInternal::setMuteAttributeStubDispatcher(
                &::v1_0::org::genivi::mediamanager::PlayerStub::getMuteAttribute,
                &PlayerStubRemoteEvent::onRemoteSetMuteAttribute,
                &PlayerStubRemoteEvent::onRemoteMuteAttributeChanged
                ,&PlayerStubAdapter::fireMuteAttributeChanged
                ,"i"
                );
/**
 * description: Shuffle or unshuffle the current play queue. Shuffling,
                  
 *   un-shuffling and then re-shuffling will yield two different
                  
 *   shufflings (which are not guaranteed to be different)
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        ::v1_0::org::genivi::mediamanager::PlayerTypes::ShuffleStatus
        > PlayerDBusStubAdapterInternal::getShuffleAttributeStubDispatcher(
            &::v1_0::org::genivi::mediamanager::PlayerStub::getShuffleAttribute
            , "i"
            );
CommonAPI::DBus::DBusSetObservableAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        ::v1_0::org::genivi::mediamanager::PlayerTypes::ShuffleStatus
        > PlayerDBusStubAdapterInternal::setShuffleAttributeStubDispatcher(
                &::v1_0::org::genivi::mediamanager::PlayerStub::getShuffleAttribute,
                &PlayerStubRemoteEvent::onRemoteSetShuffleAttribute,
                &PlayerStubRemoteEvent::onRemoteShuffleAttributeChanged
                ,&PlayerStubAdapter::fireShuffleAttributeChanged
                ,"i"
                );
/**
 * description: Toggle repeat for the current playlist. If enabled,
                     
 *   playback will continue with the first item of the current
                    
 *    play queue when the last item has finished playing
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        ::v1_0::org::genivi::mediamanager::PlayerTypes::RepeatStatus
        > PlayerDBusStubAdapterInternal::getRepeatAttributeStubDispatcher(
            &::v1_0::org::genivi::mediamanager::PlayerStub::getRepeatAttribute
            , "i"
            );
CommonAPI::DBus::DBusSetObservableAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        ::v1_0::org::genivi::mediamanager::PlayerTypes::RepeatStatus
        > PlayerDBusStubAdapterInternal::setRepeatAttributeStubDispatcher(
                &::v1_0::org::genivi::mediamanager::PlayerStub::getRepeatAttribute,
                &PlayerStubRemoteEvent::onRemoteSetRepeatAttribute,
                &PlayerStubRemoteEvent::onRemoteRepeatAttributeChanged
                ,&PlayerStubAdapter::fireRepeatAttributeChanged
                ,"i"
                );
/**
 * description: Get or set the playback rate. The allowed range of values
                     
 *   is -16 to +16
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        double
        > PlayerDBusStubAdapterInternal::getRateAttributeStubDispatcher(
            &::v1_0::org::genivi::mediamanager::PlayerStub::getRateAttribute
            , "d"
            );
CommonAPI::DBus::DBusSetObservableAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        double
        > PlayerDBusStubAdapterInternal::setRateAttributeStubDispatcher(
                &::v1_0::org::genivi::mediamanager::PlayerStub::getRateAttribute,
                &PlayerStubRemoteEvent::onRemoteSetRateAttribute,
                &PlayerStubRemoteEvent::onRemoteRateAttributeChanged
                ,&PlayerStubAdapter::fireRateAttributeChanged
                ,"d"
                );
/**
 * description: Get or set volume, 0 is muted, and 1.0 means maximum
                     
 *   volume. Values outside this range will be capped
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        double
        > PlayerDBusStubAdapterInternal::getVolumeAttributeStubDispatcher(
            &::v1_0::org::genivi::mediamanager::PlayerStub::getVolumeAttribute
            , "d"
            );
CommonAPI::DBus::DBusSetObservableAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        double
        > PlayerDBusStubAdapterInternal::setVolumeAttributeStubDispatcher(
                &::v1_0::org::genivi::mediamanager::PlayerStub::getVolumeAttribute,
                &PlayerStubRemoteEvent::onRemoteSetVolumeAttribute,
                &PlayerStubRemoteEvent::onRemoteVolumeAttributeChanged
                ,&PlayerStubAdapter::fireVolumeAttributeChanged
                ,"d"
                );
/**
 * description: Indicates whether Next() is available
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        bool
        > PlayerDBusStubAdapterInternal::getCanGoNextAttributeStubDispatcher(
            &::v1_0::org::genivi::mediamanager::PlayerStub::getCanGoNextAttribute
            , "b"
            );
/**
 * description: Indicates whether Previous() is available
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        bool
        > PlayerDBusStubAdapterInternal::getCanGoPreviousAttributeStubDispatcher(
            &::v1_0::org::genivi::mediamanager::PlayerStub::getCanGoPreviousAttribute
            , "b"
            );
/**
 * description: Indicates whether Pause() is available
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        bool
        > PlayerDBusStubAdapterInternal::getCanPauseAttributeStubDispatcher(
            &::v1_0::org::genivi::mediamanager::PlayerStub::getCanPauseAttribute
            , "b"
            );
/**
 * description: Indicates whether Play() is available
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        bool
        > PlayerDBusStubAdapterInternal::getCanPlayAttributeStubDispatcher(
            &::v1_0::org::genivi::mediamanager::PlayerStub::getCanPlayAttribute
            , "b"
            );
/**
 * description: Indicates whether Seek and SetPosition() are available
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        bool
        > PlayerDBusStubAdapterInternal::getCanSeekAttributeStubDispatcher(
            &::v1_0::org::genivi::mediamanager::PlayerStub::getCanSeekAttribute
            , "b"
            );
/**
 * description: Indicates the index in the play queue of the currently
                     
 *   playing track
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        uint64_t
        > PlayerDBusStubAdapterInternal::getCurrentTrackAttributeStubDispatcher(
            &::v1_0::org::genivi::mediamanager::PlayerStub::getCurrentTrackAttribute
            , "t"
            );
/**
 * description: Indicates current playback status
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        ::v1_0::org::genivi::mediamanager::PlayerTypes::PlaybackStatus
        > PlayerDBusStubAdapterInternal::getPlaybackStatusAttributeStubDispatcher(
            &::v1_0::org::genivi::mediamanager::PlayerStub::getPlaybackStatusAttribute
            , "i"
            );
/**
 * description: Indicates current position in the currently playing
                      track
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        uint64_t
        > PlayerDBusStubAdapterInternal::getPositionAttributeStubDispatcher(
            &::v1_0::org::genivi::mediamanager::PlayerStub::getPositionAttribute
            , "t"
            );
/**
 * description: Indicates duration of the current track
 */
CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1_0::org::genivi::mediamanager::PlayerStub,
        uint64_t
        > PlayerDBusStubAdapterInternal::getDurationAttributeStubDispatcher(
            &::v1_0::org::genivi::mediamanager::PlayerStub::getDurationAttribute
            , "t"
            );



/**
 * description: Skip to the next track in the play queue. If there is no
                      
 *   next track, playback is stopped. If playback is paused or
                    
 *     stopped, this function will set the next plack to be
                      
 *   played once playback is activated
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1_0::org::genivi::mediamanager::PlayerStub,
    std::tuple<>,
    std::tuple<::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError>,
    std::tuple<>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PlayerDBusStubAdapterInternal::nextStubDispatcher(
    &PlayerStub::next, "i",
					std::make_tuple(),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Open the supplied Uri for playback in the playback engine.
         returns:
 *   INVALID_URI When an invalid URI is supplied
                              
 *   (decided by playback engine)
                   NO_ERROR    On success
 * param: uri URI of media to play, uri format is decided by backend
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1_0::org::genivi::mediamanager::PlayerStub,
    std::tuple<std::string>,
    std::tuple<::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError>,
    std::tuple<CommonAPI::DBus::StringDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PlayerDBusStubAdapterInternal::openUriStubDispatcher(
    &PlayerStub::openUri, "i",
					std::make_tuple(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Enqueue the supplied Uri for playback in the playback engine.
         returns:
 *   INVALID_URI When an invalid URI is supplied
                              
 *   (decided by playback engine)
                  NO_ERROR    On success
 * param: uri URI of media to enqueue, uri format is decided by backend
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1_0::org::genivi::mediamanager::PlayerStub,
    std::tuple<std::string>,
    std::tuple<::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError>,
    std::tuple<CommonAPI::DBus::StringDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PlayerDBusStubAdapterInternal::enqueueUriStubDispatcher(
    &PlayerStub::enqueueUri, "i",
					std::make_tuple(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Dequeue the item with the supplied index in the playback
                     
 *   engine.
 * param: pos index of media to dequeue
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1_0::org::genivi::mediamanager::PlayerStub,
    std::tuple<uint64_t>,
    std::tuple<::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError>,
    std::tuple<CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PlayerDBusStubAdapterInternal::dequeueIndexStubDispatcher(
    &PlayerStub::dequeueIndex, "i",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Retrieve the current play queue. The format of the result
                     
 *   object is described in MediaTypes.fidl
         returns: Current play queue
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1_0::org::genivi::mediamanager::PlayerStub,
    std::tuple<>,
    std::tuple<::v1_0::org::genivi::mediamanager::MediaTypes::ResultMapList, ::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError>,
    std::tuple<>,
    std::tuple<::v1_0::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t, CommonAPI::EmptyDeployment>
    
    > PlayerDBusStubAdapterInternal::getCurrentPlayQueueStubDispatcher(
    &PlayerStub::getCurrentPlayQueue, "aa{s(yv)}i",
					std::make_tuple(),
                	std::make_tuple(static_cast<::v1_0::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Dequeue all elements, emptying the play queue
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1_0::org::genivi::mediamanager::PlayerStub,
    std::tuple<>,
    std::tuple<::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError>,
    std::tuple<>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PlayerDBusStubAdapterInternal::dequeueAllStubDispatcher(
    &PlayerStub::dequeueAll, "i",
					std::make_tuple(),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Use the supplied playlist as the current play queue. If
                     
 *   the play queue is invalid, the old play queue is
                     
 *   untouched.
         returns: BAD_PLAYLIST If playlist can not be loaded
      
 *               NO_ERROR     On success
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1_0::org::genivi::mediamanager::PlayerStub,
    std::tuple<std::string>,
    std::tuple<::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError>,
    std::tuple<CommonAPI::DBus::StringDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PlayerDBusStubAdapterInternal::openPlaylistStubDispatcher(
    &PlayerStub::openPlaylist, "i",
					std::make_tuple(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Pause playback in the playback engine.
                       If already
 *   paused, this has no effect
                       Note: If CanPause is false,
 *   this has no effect
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1_0::org::genivi::mediamanager::PlayerStub,
    std::tuple<>,
    std::tuple<::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError>,
    std::tuple<>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PlayerDBusStubAdapterInternal::pauseStubDispatcher(
    &PlayerStub::pause, "i",
					std::make_tuple(),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Start or resume playback in the playback engine.
                       If
 *   playback is already commencing, this has not effect.
                       If
 *   paused, playback resumes from the current position.
                       If
 *   there is no track to play, calling this has no effect
                      
 *   Note: If CanPlay is false, this has no effect
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1_0::org::genivi::mediamanager::PlayerStub,
    std::tuple<>,
    std::tuple<::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError>,
    std::tuple<>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PlayerDBusStubAdapterInternal::playStubDispatcher(
    &PlayerStub::play, "i",
					std::make_tuple(),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Starts playback (see Play) if paused
                      Pauses playback (see
 *   Pause) is playing
 * see: Play
 * see: Pause
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1_0::org::genivi::mediamanager::PlayerStub,
    std::tuple<>,
    std::tuple<::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError>,
    std::tuple<>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PlayerDBusStubAdapterInternal::playPauseStubDispatcher(
    &PlayerStub::playPause, "i",
					std::make_tuple(),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Loads previous track in play queue
                      If there is no
 *   previous track, playback is stopped
                      If playback is
 *   stopped or paused, it remains this way,
                      but the next
 *   track to be played will the set
                      by this function
       
 *                 Note: If CanGoPrevious is false, this has no effect
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1_0::org::genivi::mediamanager::PlayerStub,
    std::tuple<>,
    std::tuple<::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError>,
    std::tuple<>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PlayerDBusStubAdapterInternal::previousStubDispatcher(
    &PlayerStub::previous, "i",
					std::make_tuple(),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Seek relatively in the current track
                      If a negative seek
 *   leads to a play position less than 0,
                      the play position
 *   will be set to 0.
                      If a positive seek leads outside the
 *   length of the current
                      track, this is treated like a call
 *   to Next()
                      Note: If CanSeek is false, this has no effect
 * param: pos Relative seek amount in microseconds
 * see: Next
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1_0::org::genivi::mediamanager::PlayerStub,
    std::tuple<int64_t>,
    std::tuple<::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError>,
    std::tuple<CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PlayerDBusStubAdapterInternal::seekStubDispatcher(
    &PlayerStub::seek, "i",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Jump to the specified position in the current
                       If the
 *   position is not within range of the current track,
                       do
 *   nothing
         Note: If CanSeek is false, this has no effect
 * param: pos Absolute position in microseconds
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1_0::org::genivi::mediamanager::PlayerStub,
    std::tuple<uint64_t>,
    std::tuple<::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError>,
    std::tuple<CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > PlayerDBusStubAdapterInternal::setPositionStubDispatcher(
    &PlayerStub::setPosition, "i",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));


/**
 * description: Mute or unmute audio. When muted, the player backend will
                     
 *   not produce any audio output.
 */
void PlayerDBusStubAdapterInternal::fireMuteAttributeChanged(const ::v1_0::org::genivi::mediamanager::PlayerTypes::MuteStatus& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    ::v1_0::org::genivi::mediamanager::PlayerTypes::MuteStatus
    >>
        ::sendSignal(
            *this,
            "onMuteAttributeChanged",
            "i",
            value
    
    );
}
/**
 * description: Shuffle or unshuffle the current play queue. Shuffling,
                  
 *   un-shuffling and then re-shuffling will yield two different
                  
 *   shufflings (which are not guaranteed to be different)
 */
void PlayerDBusStubAdapterInternal::fireShuffleAttributeChanged(const ::v1_0::org::genivi::mediamanager::PlayerTypes::ShuffleStatus& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    ::v1_0::org::genivi::mediamanager::PlayerTypes::ShuffleStatus
    >>
        ::sendSignal(
            *this,
            "onShuffleAttributeChanged",
            "i",
            value
    
    );
}
/**
 * description: Toggle repeat for the current playlist. If enabled,
                     
 *   playback will continue with the first item of the current
                    
 *    play queue when the last item has finished playing
 */
void PlayerDBusStubAdapterInternal::fireRepeatAttributeChanged(const ::v1_0::org::genivi::mediamanager::PlayerTypes::RepeatStatus& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    ::v1_0::org::genivi::mediamanager::PlayerTypes::RepeatStatus
    >>
        ::sendSignal(
            *this,
            "onRepeatAttributeChanged",
            "i",
            value
    
    );
}
/**
 * description: Get or set the playback rate. The allowed range of values
                     
 *   is -16 to +16
 */
void PlayerDBusStubAdapterInternal::fireRateAttributeChanged(const double& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    double
    >>
        ::sendSignal(
            *this,
            "onRateAttributeChanged",
            "d",
            value
    
    );
}
/**
 * description: Get or set volume, 0 is muted, and 1.0 means maximum
                     
 *   volume. Values outside this range will be capped
 */
void PlayerDBusStubAdapterInternal::fireVolumeAttributeChanged(const double& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    double
    >>
        ::sendSignal(
            *this,
            "onVolumeAttributeChanged",
            "d",
            value
    
    );
}
/**
 * description: Indicates whether Next() is available
 */
void PlayerDBusStubAdapterInternal::fireCanGoNextAttributeChanged(const bool& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    bool
    >>
        ::sendSignal(
            *this,
            "onCanGoNextAttributeChanged",
            "b",
            value
    
    );
}
/**
 * description: Indicates whether Previous() is available
 */
void PlayerDBusStubAdapterInternal::fireCanGoPreviousAttributeChanged(const bool& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    bool
    >>
        ::sendSignal(
            *this,
            "onCanGoPreviousAttributeChanged",
            "b",
            value
    
    );
}
/**
 * description: Indicates whether Pause() is available
 */
void PlayerDBusStubAdapterInternal::fireCanPauseAttributeChanged(const bool& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    bool
    >>
        ::sendSignal(
            *this,
            "onCanPauseAttributeChanged",
            "b",
            value
    
    );
}
/**
 * description: Indicates whether Play() is available
 */
void PlayerDBusStubAdapterInternal::fireCanPlayAttributeChanged(const bool& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    bool
    >>
        ::sendSignal(
            *this,
            "onCanPlayAttributeChanged",
            "b",
            value
    
    );
}
/**
 * description: Indicates whether Seek and SetPosition() are available
 */
void PlayerDBusStubAdapterInternal::fireCanSeekAttributeChanged(const bool& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    bool
    >>
        ::sendSignal(
            *this,
            "onCanSeekAttributeChanged",
            "b",
            value
    
    );
}
/**
 * description: Indicates the index in the play queue of the currently
                     
 *   playing track
 */
void PlayerDBusStubAdapterInternal::fireCurrentTrackAttributeChanged(const uint64_t& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    uint64_t
    >>
        ::sendSignal(
            *this,
            "onCurrentTrackAttributeChanged",
            "t",
            value
    
    );
}
/**
 * description: Indicates current playback status
 */
void PlayerDBusStubAdapterInternal::firePlaybackStatusAttributeChanged(const ::v1_0::org::genivi::mediamanager::PlayerTypes::PlaybackStatus& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    ::v1_0::org::genivi::mediamanager::PlayerTypes::PlaybackStatus
    >>
        ::sendSignal(
            *this,
            "onPlaybackStatusAttributeChanged",
            "i",
            value
    
    );
}
/**
 * description: Indicates duration of the current track
 */
void PlayerDBusStubAdapterInternal::fireDurationAttributeChanged(const uint64_t& value) {
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    uint64_t
    >>
        ::sendSignal(
            *this,
            "onDurationAttributeChanged",
            "t",
            value
    
    );
}



const PlayerDBusStubAdapterHelper::StubDispatcherTable& PlayerDBusStubAdapterInternal::getStubDispatcherTable() {
    return stubDispatcherTable_;
}

const CommonAPI::DBus::StubAttributeTable& PlayerDBusStubAdapterInternal::getStubAttributeTable() {
    return stubAttributeTable_;
}

PlayerDBusStubAdapterInternal::PlayerDBusStubAdapterInternal(
        const CommonAPI::DBus::DBusAddress &_address,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection,
        const std::shared_ptr<CommonAPI::StubBase> &_stub)
	: CommonAPI::DBus::DBusStubAdapter(_address, _connection,false),
      PlayerDBusStubAdapterHelper(_address, _connection, std::dynamic_pointer_cast<PlayerStub>(_stub), false),
      stubDispatcherTable_({
            /**
             * description: Mute or unmute audio. When muted, the player backend will
                                 
             *   not produce any audio output.
             */
            { { "getMuteAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getMuteAttributeStubDispatcher }
            , { { "setMuteAttribute", "i" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::setMuteAttributeStubDispatcher },
            /**
             * description: Shuffle or unshuffle the current play queue. Shuffling,
                              
             *   un-shuffling and then re-shuffling will yield two different
                              
             *   shufflings (which are not guaranteed to be different)
             */
            { { "getShuffleAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getShuffleAttributeStubDispatcher }
            , { { "setShuffleAttribute", "i" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::setShuffleAttributeStubDispatcher },
            /**
             * description: Toggle repeat for the current playlist. If enabled,
                                 
             *   playback will continue with the first item of the current
                                
             *    play queue when the last item has finished playing
             */
            { { "getRepeatAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getRepeatAttributeStubDispatcher }
            , { { "setRepeatAttribute", "i" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::setRepeatAttributeStubDispatcher },
            /**
             * description: Get or set the playback rate. The allowed range of values
                                 
             *   is -16 to +16
             */
            { { "getRateAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getRateAttributeStubDispatcher }
            , { { "setRateAttribute", "d" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::setRateAttributeStubDispatcher },
            /**
             * description: Get or set volume, 0 is muted, and 1.0 means maximum
                                 
             *   volume. Values outside this range will be capped
             */
            { { "getVolumeAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getVolumeAttributeStubDispatcher }
            , { { "setVolumeAttribute", "d" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::setVolumeAttributeStubDispatcher },
            /**
             * description: Indicates whether Next() is available
             */
            { { "getCanGoNextAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getCanGoNextAttributeStubDispatcher },
            /**
             * description: Indicates whether Previous() is available
             */
            { { "getCanGoPreviousAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getCanGoPreviousAttributeStubDispatcher },
            /**
             * description: Indicates whether Pause() is available
             */
            { { "getCanPauseAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getCanPauseAttributeStubDispatcher },
            /**
             * description: Indicates whether Play() is available
             */
            { { "getCanPlayAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getCanPlayAttributeStubDispatcher },
            /**
             * description: Indicates whether Seek and SetPosition() are available
             */
            { { "getCanSeekAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getCanSeekAttributeStubDispatcher },
            /**
             * description: Indicates the index in the play queue of the currently
                                 
             *   playing track
             */
            { { "getCurrentTrackAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getCurrentTrackAttributeStubDispatcher },
            /**
             * description: Indicates current playback status
             */
            { { "getPlaybackStatusAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getPlaybackStatusAttributeStubDispatcher },
            /**
             * description: Indicates current position in the currently playing
                                  track
             */
            { { "getPositionAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getPositionAttributeStubDispatcher },
            /**
             * description: Indicates duration of the current track
             */
            { { "getDurationAttribute", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getDurationAttributeStubDispatcher }
            ,
            /**
             * description: Skip to the next track in the play queue. If there is no
                                  
             *   next track, playback is stopped. If playback is paused or
                                
             *     stopped, this function will set the next plack to be
                                  
             *   played once playback is activated
             */
            { { "next", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::nextStubDispatcher },
            /**
             * description: Open the supplied Uri for playback in the playback engine.
                     returns:
             *   INVALID_URI When an invalid URI is supplied
                                          
             *   (decided by playback engine)
                               NO_ERROR    On success
             * param: uri URI of media to play, uri format is decided by backend
             */
            { { "openUri", "s" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::openUriStubDispatcher },
            /**
             * description: Enqueue the supplied Uri for playback in the playback engine.
                     returns:
             *   INVALID_URI When an invalid URI is supplied
                                          
             *   (decided by playback engine)
                              NO_ERROR    On success
             * param: uri URI of media to enqueue, uri format is decided by backend
             */
            { { "enqueueUri", "s" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::enqueueUriStubDispatcher },
            /**
             * description: Dequeue the item with the supplied index in the playback
                                 
             *   engine.
             * param: pos index of media to dequeue
             */
            { { "dequeueIndex", "t" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::dequeueIndexStubDispatcher },
            /**
             * description: Retrieve the current play queue. The format of the result
                                 
             *   object is described in MediaTypes.fidl
                     returns: Current play queue
             */
            { { "getCurrentPlayQueue", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getCurrentPlayQueueStubDispatcher },
            /**
             * description: Dequeue all elements, emptying the play queue
             */
            { { "dequeueAll", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::dequeueAllStubDispatcher },
            /**
             * description: Use the supplied playlist as the current play queue. If
                                 
             *   the play queue is invalid, the old play queue is
                                 
             *   untouched.
                     returns: BAD_PLAYLIST If playlist can not be loaded
                  
             *               NO_ERROR     On success
             */
            { { "openPlaylist", "s" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::openPlaylistStubDispatcher },
            /**
             * description: Pause playback in the playback engine.
                                   If already
             *   paused, this has no effect
                                   Note: If CanPause is false,
             *   this has no effect
             */
            { { "pause", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::pauseStubDispatcher },
            /**
             * description: Start or resume playback in the playback engine.
                                   If
             *   playback is already commencing, this has not effect.
                                   If
             *   paused, playback resumes from the current position.
                                   If
             *   there is no track to play, calling this has no effect
                                  
             *   Note: If CanPlay is false, this has no effect
             */
            { { "play", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::playStubDispatcher },
            /**
             * description: Starts playback (see Play) if paused
                                  Pauses playback (see
             *   Pause) is playing
             * see: Play
             * see: Pause
             */
            { { "playPause", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::playPauseStubDispatcher },
            /**
             * description: Loads previous track in play queue
                                  If there is no
             *   previous track, playback is stopped
                                  If playback is
             *   stopped or paused, it remains this way,
                                  but the next
             *   track to be played will the set
                                  by this function
                   
             *                 Note: If CanGoPrevious is false, this has no effect
             */
            { { "previous", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::previousStubDispatcher },
            /**
             * description: Seek relatively in the current track
                                  If a negative seek
             *   leads to a play position less than 0,
                                  the play position
             *   will be set to 0.
                                  If a positive seek leads outside the
             *   length of the current
                                  track, this is treated like a call
             *   to Next()
                                  Note: If CanSeek is false, this has no effect
             * param: pos Relative seek amount in microseconds
             * see: Next
             */
            { { "seek", "x" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::seekStubDispatcher },
            /**
             * description: Jump to the specified position in the current
                                   If the
             *   position is not within range of the current track,
                                   do
             *   nothing
                     Note: If CanSeek is false, this has no effect
             * param: pos Absolute position in microseconds
             */
            { { "setPosition", "t" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::setPositionStubDispatcher }
            }),
        stubAttributeTable_() {

    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::mediamanager::PlayerDBusStubAdapterInternal::getPlayerInterfaceVersionStubDispatcher });
}

const bool PlayerDBusStubAdapterInternal::hasFreedesktopProperties() {
    return false;
}

} // namespace mediamanager
} // namespace genivi
} // namespace org
} // namespace v1_0
