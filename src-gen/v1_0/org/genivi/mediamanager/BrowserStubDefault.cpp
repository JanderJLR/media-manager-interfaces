/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.3.v201507280808.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include <v1_0/org/genivi/mediamanager/BrowserStubDefault.hpp>
#include <assert.h>

namespace v1_0 {
namespace org {
namespace genivi {
namespace mediamanager {

BrowserStubDefault::BrowserStubDefault():
        remoteEventHandler_(this),
        interfaceVersion_(Browser::getInterfaceVersion()) {
}

const CommonAPI::Version& BrowserStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> _client) {
    return interfaceVersion_;
}

BrowserStubRemoteEvent* BrowserStubDefault::initStubAdapter(const std::shared_ptr<BrowserStubAdapter> &_adapter) {
    CommonAPI::Stub<BrowserStubAdapter, BrowserStubRemoteEvent>::stubAdapter_ = _adapter;
    return &remoteEventHandler_;
}


/**
 * description: Return a list of all media manager identifiers. These are
         used to
 *   indicate which media manager we should interact with.
         returns: A list
 *   of all media managers found
 */
void BrowserStubDefault::discoverMediaManagers(const std::shared_ptr<CommonAPI::ClientId> _client, discoverMediaManagersReply_t _reply) {
    std::vector<std::string> identifiers = {};
    ::v1_0::org::genivi::mediamanager::BrowserTypes::BrowserError e;
    _reply(identifiers, e);
}

/**
 * description: List all containers below the given path.
         returns: ResultMapList of
 *   all containers with the given path as parent.
         	   	  See
 *   MediaTypes.fidl for a list of allowed keys.
         errors: NO_CONNECTION if
 *   no connection can be established to underlying
                 browsing
 *   engine
                 BAD_PATH if path parameter is invalid
 * param: path The path to search for containers. The format of the path

 *   depends on the underlying browsing backend
 * param: offset: The offset to use for indexing the results list
 * param: count: The number of results to return, starting from offset
 * param: filter: Array of keys to include in resulting ResultMapList
 */
void BrowserStubDefault::listContainers(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _path, uint64_t _offset, uint64_t _count, std::vector<std::string> _filter, listContainersReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::MediaTypes::ResultMapList m;
    ::v1_0::org::genivi::mediamanager::BrowserTypes::BrowserError e;
    _reply(m, e);
}

/**
 * description: Extends ListContainers with sorting capabilities
 * param: sortKey Key to sort ResultMapList on
 */
void BrowserStubDefault::listContainersEx(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _path, uint64_t _offset, uint64_t _count, std::vector<std::string> _filter, ::v1_0::org::genivi::mediamanager::BrowserTypes::SortKey _sortKey, listContainersExReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::MediaTypes::ResultMapList m;
    ::v1_0::org::genivi::mediamanager::BrowserTypes::BrowserError e;
    _reply(m, e);
}

/**
 * description: List all items in the given container
         returns: A ResultMapList of all
 *   items with the given container as parent.
         		  See MediaTypes.fidl for
 *   a list of allowed keys.
         errors: NO_CONNECTION if no connection can be
 *   established to underlying
                 browsing engine

 *   BAD_PATH if path parameter is invalid
 * param: path The path of the container to search for items.
                The format
 *   of the path depends on the underlying browsing
                backend
 * param: offset: The offset to use for indexing the results list
 * param: count: The number of results to return, starting from offset
 * param: filter: Array of keys to include in resulting ResultMapList
 */
void BrowserStubDefault::listItems(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _path, uint64_t _offset, uint64_t _count, std::vector<std::string> _filter, listItemsReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::MediaTypes::ResultMapList m;
    ::v1_0::org::genivi::mediamanager::BrowserTypes::BrowserError e;
    _reply(m, e);
}

/**
 * description: Extends ListItems with sorting capabilities
 * param: sortKey Key to sort ResultMapList
 */
void BrowserStubDefault::listItemsEx(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _path, uint64_t _offset, uint64_t _count, std::vector<std::string> _filter, ::v1_0::org::genivi::mediamanager::BrowserTypes::SortKey _sortKey, listItemsExReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::MediaTypes::ResultMapList m;
    ::v1_0::org::genivi::mediamanager::BrowserTypes::BrowserError e;
    _reply(m, e);
}

/**
 * description: List all children in the given container
         returns: A ResultMapList of
 *   all children with the given container as parent.
         		  See
 *   MediaTypes.fidl for a list of allowed keys.
         errors: NO_CONNECTION if
 *   no connection can be established to underlying
                  browsing
 *   engine
                  BAD_PATH if path parameter is invalid
 * param: path The path of the container to search for children.
                The
 *   format of the path depends on the underlying browsing
                backend
 * param: offset: The offset to use for indexing the results list
 * param: count: The number of results to return, starting from offset
 * param: filter: Array of keys to include in resulting ResultMapList
 */
void BrowserStubDefault::listChildren(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _path, uint64_t _offset, uint64_t _count, std::vector<std::string> _filter, listChildrenReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::MediaTypes::ResultMapList m;
    ::v1_0::org::genivi::mediamanager::BrowserTypes::BrowserError e;
    _reply(m, e);
}

/**
 * description: Extends ListChildren with sorting capabilities
 * param: sortKey Key to sort ResultMapList on
 */
void BrowserStubDefault::listChildrenEx(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _path, uint64_t _offset, uint64_t _count, std::vector<std::string> _filter, ::v1_0::org::genivi::mediamanager::BrowserTypes::SortKey _sortKey, listChildrenExReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::MediaTypes::ResultMapList m;
    ::v1_0::org::genivi::mediamanager::BrowserTypes::BrowserError e;
    _reply(m, e);
}

/**
 * description: Search for children in the given container
         returns: A ResultMapList of
 *   all children matching the search criteria with
                   the given
 *   container as parent.See MediaTypes.fidl for a list of

 *   allowed keys.
         errors: NO_CONNECTION if no connection can be
 *   established to underlying
                 browsing engine

 *   BAD_PATH if path parameter is invalid
 * param: path The path of the container to search for children.
                The
 *   format of the path depends on the underlying browsing
                backend
 * param: query Search query to match children against. The format of the

 *   query depends on the underlying browsing backend
 * param: offset: The offset to use for indexing the results list
 * param: count: The number of results to return, starting from offset
 * param: filter: Array of keys to include in resulting ResultMapList
 */
void BrowserStubDefault::searchObjects(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _path, std::string _query, uint64_t _offset, uint64_t _count, std::vector<std::string> _filter, searchObjectsReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::MediaTypes::ResultMapList m;
    ::v1_0::org::genivi::mediamanager::BrowserTypes::BrowserError e;
    _reply(m, e);
}

/**
 * description: Extends SearchObjects with sorting capabilities
 * param: sortKey Key to sort ResultMapList on
 */
void BrowserStubDefault::searchObjectsEx(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _path, std::string _query, uint64_t _offset, uint64_t _count, std::vector<std::string> _filter, ::v1_0::org::genivi::mediamanager::BrowserTypes::SortKey _sortKey, searchObjectsExReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::MediaTypes::ResultMapList m;
    ::v1_0::org::genivi::mediamanager::BrowserTypes::BrowserError e;
    _reply(m, e);
}

/**
 * description: Get a list of all initial letters and their index in the

 *   given container
         returns: A list of tuples of initial letters and
 *   their first
                   observed position when sorting according to
 *   sortKey
         errors: NO_CONNECTION if no connection can be established to
 *   underlying
                 browsing engine
                 BAD_PATH if path
 *   parameter is invalid
 * param: container: Container to build index list for
 * param: count: How many (unsorted) items should be traversed to build

 *          index
 * param: filter: List of initial letters to include
 * param: sortKey: Key to sort on when building index list
 */
void BrowserStubDefault::listIndexes(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _container, uint64_t _count, std::vector<std::string> _filter, ::v1_0::org::genivi::mediamanager::BrowserTypes::SortKey _sortKey, listIndexesReply_t _reply) {
    std::string indexes = "";
    ::v1_0::org::genivi::mediamanager::BrowserTypes::BrowserError e;
    _reply(indexes, e);
}

/**
 * description: Create a new empty container with path used as root
         returns: Path
 *   identifier for the newly created container
         errors: NO_CONNECTION if
 *   no connection can be established to underlying
                  browsing
 *   engine
                  BAD_PATH if path parameter is invalid
 * param: path: Path to place the newly created container in
 * param: displayName: Display name for the new container
 * param: childTypes: Array of allowed types on children in new container
 */
void BrowserStubDefault::createContainer(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _path, std::string _displayName, std::vector<std::string> _childTypes, createContainerReply_t _reply) {
    std::string pathIdentifier = "";
    ::v1_0::org::genivi::mediamanager::BrowserTypes::BrowserError e;
    _reply(pathIdentifier, e);
}

/**
 * description: Place a reference in a container, pointing to an object
         returns: Path
 *   identifier for the container containing the reference
         errors:
 *   NO_CONNECTION if no connection can be established to underlying

 *      browsing engine
                  BAD_PATH if path parameter is invalid
 * param: path: Path to place the newly created container in
 * param: objectPath: Path to object to create reference to
 */
void BrowserStubDefault::createReference(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _path, std::string _objectPath, createReferenceReply_t _reply) {
    std::string pathIdentifier = "";
    ::v1_0::org::genivi::mediamanager::BrowserTypes::BrowserError e;
    _reply(pathIdentifier, e);
}




BrowserStubDefault::RemoteEventHandler::RemoteEventHandler(BrowserStubDefault *_defaultStub)
    :
      defaultStub_(_defaultStub) {
}

} // namespace mediamanager
} // namespace genivi
} // namespace org
} // namespace v1_0
