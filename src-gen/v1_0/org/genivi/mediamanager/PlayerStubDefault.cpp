/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.3.v201507280808.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include <v1_0/org/genivi/mediamanager/PlayerStubDefault.hpp>
#include <assert.h>

namespace v1_0 {
namespace org {
namespace genivi {
namespace mediamanager {

PlayerStubDefault::PlayerStubDefault():
        remoteEventHandler_(this),
        interfaceVersion_(Player::getInterfaceVersion()) {
}

const CommonAPI::Version& PlayerStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> _client) {
    return interfaceVersion_;
}

PlayerStubRemoteEvent* PlayerStubDefault::initStubAdapter(const std::shared_ptr<PlayerStubAdapter> &_adapter) {
    CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_ = _adapter;
    return &remoteEventHandler_;
}

const ::v1_0::org::genivi::mediamanager::PlayerTypes::MuteStatus& PlayerStubDefault::getMuteAttribute() {
    return muteAttributeValue_;
}

const ::v1_0::org::genivi::mediamanager::PlayerTypes::MuteStatus& PlayerStubDefault::getMuteAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    return getMuteAttribute();
}

void PlayerStubDefault::setMuteAttribute(::v1_0::org::genivi::mediamanager::PlayerTypes::MuteStatus _value) {
    const bool valueChanged = trySetMuteAttribute(std::move(_value));
    if (valueChanged && CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_ != NULL) {
         CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_->fireMuteAttributeChanged(muteAttributeValue_);
     }
}

bool PlayerStubDefault::trySetMuteAttribute(::v1_0::org::genivi::mediamanager::PlayerTypes::MuteStatus _value) {
    if (!validateMuteAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (muteAttributeValue_ != _value);
    muteAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool PlayerStubDefault::validateMuteAttributeRequestedValue(const ::v1_0::org::genivi::mediamanager::PlayerTypes::MuteStatus &_value) {
    return true;
}

void PlayerStubDefault::setMuteAttribute(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1_0::org::genivi::mediamanager::PlayerTypes::MuteStatus _value) {
    setMuteAttribute(_value);
}

void PlayerStubDefault::onRemoteMuteAttributeChanged() {
    // No operation in default
}

void PlayerStubDefault::RemoteEventHandler::onRemoteMuteAttributeChanged() {
	assert(defaultStub_ !=NULL);
    defaultStub_->onRemoteMuteAttributeChanged();
}

bool PlayerStubDefault::RemoteEventHandler::onRemoteSetMuteAttribute(::v1_0::org::genivi::mediamanager::PlayerTypes::MuteStatus _value) {
	assert(defaultStub_ !=NULL);
    return defaultStub_->trySetMuteAttribute(std::move(_value));
}

bool PlayerStubDefault::RemoteEventHandler::onRemoteSetMuteAttribute(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1_0::org::genivi::mediamanager::PlayerTypes::MuteStatus _value) {
    return onRemoteSetMuteAttribute(_value);
}

const ::v1_0::org::genivi::mediamanager::PlayerTypes::ShuffleStatus& PlayerStubDefault::getShuffleAttribute() {
    return shuffleAttributeValue_;
}

const ::v1_0::org::genivi::mediamanager::PlayerTypes::ShuffleStatus& PlayerStubDefault::getShuffleAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    return getShuffleAttribute();
}

void PlayerStubDefault::setShuffleAttribute(::v1_0::org::genivi::mediamanager::PlayerTypes::ShuffleStatus _value) {
    const bool valueChanged = trySetShuffleAttribute(std::move(_value));
    if (valueChanged && CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_ != NULL) {
         CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_->fireShuffleAttributeChanged(shuffleAttributeValue_);
     }
}

bool PlayerStubDefault::trySetShuffleAttribute(::v1_0::org::genivi::mediamanager::PlayerTypes::ShuffleStatus _value) {
    if (!validateShuffleAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (shuffleAttributeValue_ != _value);
    shuffleAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool PlayerStubDefault::validateShuffleAttributeRequestedValue(const ::v1_0::org::genivi::mediamanager::PlayerTypes::ShuffleStatus &_value) {
    return true;
}

void PlayerStubDefault::setShuffleAttribute(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1_0::org::genivi::mediamanager::PlayerTypes::ShuffleStatus _value) {
    setShuffleAttribute(_value);
}

void PlayerStubDefault::onRemoteShuffleAttributeChanged() {
    // No operation in default
}

void PlayerStubDefault::RemoteEventHandler::onRemoteShuffleAttributeChanged() {
	assert(defaultStub_ !=NULL);
    defaultStub_->onRemoteShuffleAttributeChanged();
}

bool PlayerStubDefault::RemoteEventHandler::onRemoteSetShuffleAttribute(::v1_0::org::genivi::mediamanager::PlayerTypes::ShuffleStatus _value) {
	assert(defaultStub_ !=NULL);
    return defaultStub_->trySetShuffleAttribute(std::move(_value));
}

bool PlayerStubDefault::RemoteEventHandler::onRemoteSetShuffleAttribute(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1_0::org::genivi::mediamanager::PlayerTypes::ShuffleStatus _value) {
    return onRemoteSetShuffleAttribute(_value);
}

const ::v1_0::org::genivi::mediamanager::PlayerTypes::RepeatStatus& PlayerStubDefault::getRepeatAttribute() {
    return repeatAttributeValue_;
}

const ::v1_0::org::genivi::mediamanager::PlayerTypes::RepeatStatus& PlayerStubDefault::getRepeatAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    return getRepeatAttribute();
}

void PlayerStubDefault::setRepeatAttribute(::v1_0::org::genivi::mediamanager::PlayerTypes::RepeatStatus _value) {
    const bool valueChanged = trySetRepeatAttribute(std::move(_value));
    if (valueChanged && CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_ != NULL) {
         CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_->fireRepeatAttributeChanged(repeatAttributeValue_);
     }
}

bool PlayerStubDefault::trySetRepeatAttribute(::v1_0::org::genivi::mediamanager::PlayerTypes::RepeatStatus _value) {
    if (!validateRepeatAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (repeatAttributeValue_ != _value);
    repeatAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool PlayerStubDefault::validateRepeatAttributeRequestedValue(const ::v1_0::org::genivi::mediamanager::PlayerTypes::RepeatStatus &_value) {
    return true;
}

void PlayerStubDefault::setRepeatAttribute(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1_0::org::genivi::mediamanager::PlayerTypes::RepeatStatus _value) {
    setRepeatAttribute(_value);
}

void PlayerStubDefault::onRemoteRepeatAttributeChanged() {
    // No operation in default
}

void PlayerStubDefault::RemoteEventHandler::onRemoteRepeatAttributeChanged() {
	assert(defaultStub_ !=NULL);
    defaultStub_->onRemoteRepeatAttributeChanged();
}

bool PlayerStubDefault::RemoteEventHandler::onRemoteSetRepeatAttribute(::v1_0::org::genivi::mediamanager::PlayerTypes::RepeatStatus _value) {
	assert(defaultStub_ !=NULL);
    return defaultStub_->trySetRepeatAttribute(std::move(_value));
}

bool PlayerStubDefault::RemoteEventHandler::onRemoteSetRepeatAttribute(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1_0::org::genivi::mediamanager::PlayerTypes::RepeatStatus _value) {
    return onRemoteSetRepeatAttribute(_value);
}

const double& PlayerStubDefault::getRateAttribute() {
    return rateAttributeValue_;
}

const double& PlayerStubDefault::getRateAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    return getRateAttribute();
}

void PlayerStubDefault::setRateAttribute(double _value) {
    const bool valueChanged = trySetRateAttribute(std::move(_value));
    if (valueChanged && CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_ != NULL) {
         CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_->fireRateAttributeChanged(rateAttributeValue_);
     }
}

bool PlayerStubDefault::trySetRateAttribute(double _value) {
    if (!validateRateAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (rateAttributeValue_ != _value);
    rateAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool PlayerStubDefault::validateRateAttributeRequestedValue(const double &_value) {
    return true;
}

void PlayerStubDefault::setRateAttribute(const std::shared_ptr<CommonAPI::ClientId> _client, double _value) {
    setRateAttribute(_value);
}

void PlayerStubDefault::onRemoteRateAttributeChanged() {
    // No operation in default
}

void PlayerStubDefault::RemoteEventHandler::onRemoteRateAttributeChanged() {
	assert(defaultStub_ !=NULL);
    defaultStub_->onRemoteRateAttributeChanged();
}

bool PlayerStubDefault::RemoteEventHandler::onRemoteSetRateAttribute(double _value) {
	assert(defaultStub_ !=NULL);
    return defaultStub_->trySetRateAttribute(std::move(_value));
}

bool PlayerStubDefault::RemoteEventHandler::onRemoteSetRateAttribute(const std::shared_ptr<CommonAPI::ClientId> _client, double _value) {
    return onRemoteSetRateAttribute(_value);
}

const double& PlayerStubDefault::getVolumeAttribute() {
    return volumeAttributeValue_;
}

const double& PlayerStubDefault::getVolumeAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    return getVolumeAttribute();
}

void PlayerStubDefault::setVolumeAttribute(double _value) {
    const bool valueChanged = trySetVolumeAttribute(std::move(_value));
    if (valueChanged && CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_ != NULL) {
         CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_->fireVolumeAttributeChanged(volumeAttributeValue_);
     }
}

bool PlayerStubDefault::trySetVolumeAttribute(double _value) {
    if (!validateVolumeAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (volumeAttributeValue_ != _value);
    volumeAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool PlayerStubDefault::validateVolumeAttributeRequestedValue(const double &_value) {
    return true;
}

void PlayerStubDefault::setVolumeAttribute(const std::shared_ptr<CommonAPI::ClientId> _client, double _value) {
    setVolumeAttribute(_value);
}

void PlayerStubDefault::onRemoteVolumeAttributeChanged() {
    // No operation in default
}

void PlayerStubDefault::RemoteEventHandler::onRemoteVolumeAttributeChanged() {
	assert(defaultStub_ !=NULL);
    defaultStub_->onRemoteVolumeAttributeChanged();
}

bool PlayerStubDefault::RemoteEventHandler::onRemoteSetVolumeAttribute(double _value) {
	assert(defaultStub_ !=NULL);
    return defaultStub_->trySetVolumeAttribute(std::move(_value));
}

bool PlayerStubDefault::RemoteEventHandler::onRemoteSetVolumeAttribute(const std::shared_ptr<CommonAPI::ClientId> _client, double _value) {
    return onRemoteSetVolumeAttribute(_value);
}

const bool& PlayerStubDefault::getCanGoNextAttribute() {
    return canGoNextAttributeValue_;
}

const bool& PlayerStubDefault::getCanGoNextAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    return getCanGoNextAttribute();
}

void PlayerStubDefault::setCanGoNextAttribute(bool _value) {
    const bool valueChanged = trySetCanGoNextAttribute(std::move(_value));
    if (valueChanged && CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_ != NULL) {
         CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_->fireCanGoNextAttributeChanged(canGoNextAttributeValue_);
     }
}

bool PlayerStubDefault::trySetCanGoNextAttribute(bool _value) {
    if (!validateCanGoNextAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (canGoNextAttributeValue_ != _value);
    canGoNextAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool PlayerStubDefault::validateCanGoNextAttributeRequestedValue(const bool &_value) {
    return true;
}


const bool& PlayerStubDefault::getCanGoPreviousAttribute() {
    return canGoPreviousAttributeValue_;
}

const bool& PlayerStubDefault::getCanGoPreviousAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    return getCanGoPreviousAttribute();
}

void PlayerStubDefault::setCanGoPreviousAttribute(bool _value) {
    const bool valueChanged = trySetCanGoPreviousAttribute(std::move(_value));
    if (valueChanged && CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_ != NULL) {
         CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_->fireCanGoPreviousAttributeChanged(canGoPreviousAttributeValue_);
     }
}

bool PlayerStubDefault::trySetCanGoPreviousAttribute(bool _value) {
    if (!validateCanGoPreviousAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (canGoPreviousAttributeValue_ != _value);
    canGoPreviousAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool PlayerStubDefault::validateCanGoPreviousAttributeRequestedValue(const bool &_value) {
    return true;
}


const bool& PlayerStubDefault::getCanPauseAttribute() {
    return canPauseAttributeValue_;
}

const bool& PlayerStubDefault::getCanPauseAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    return getCanPauseAttribute();
}

void PlayerStubDefault::setCanPauseAttribute(bool _value) {
    const bool valueChanged = trySetCanPauseAttribute(std::move(_value));
    if (valueChanged && CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_ != NULL) {
         CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_->fireCanPauseAttributeChanged(canPauseAttributeValue_);
     }
}

bool PlayerStubDefault::trySetCanPauseAttribute(bool _value) {
    if (!validateCanPauseAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (canPauseAttributeValue_ != _value);
    canPauseAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool PlayerStubDefault::validateCanPauseAttributeRequestedValue(const bool &_value) {
    return true;
}


const bool& PlayerStubDefault::getCanPlayAttribute() {
    return canPlayAttributeValue_;
}

const bool& PlayerStubDefault::getCanPlayAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    return getCanPlayAttribute();
}

void PlayerStubDefault::setCanPlayAttribute(bool _value) {
    const bool valueChanged = trySetCanPlayAttribute(std::move(_value));
    if (valueChanged && CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_ != NULL) {
         CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_->fireCanPlayAttributeChanged(canPlayAttributeValue_);
     }
}

bool PlayerStubDefault::trySetCanPlayAttribute(bool _value) {
    if (!validateCanPlayAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (canPlayAttributeValue_ != _value);
    canPlayAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool PlayerStubDefault::validateCanPlayAttributeRequestedValue(const bool &_value) {
    return true;
}


const bool& PlayerStubDefault::getCanSeekAttribute() {
    return canSeekAttributeValue_;
}

const bool& PlayerStubDefault::getCanSeekAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    return getCanSeekAttribute();
}

void PlayerStubDefault::setCanSeekAttribute(bool _value) {
    const bool valueChanged = trySetCanSeekAttribute(std::move(_value));
    if (valueChanged && CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_ != NULL) {
         CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_->fireCanSeekAttributeChanged(canSeekAttributeValue_);
     }
}

bool PlayerStubDefault::trySetCanSeekAttribute(bool _value) {
    if (!validateCanSeekAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (canSeekAttributeValue_ != _value);
    canSeekAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool PlayerStubDefault::validateCanSeekAttributeRequestedValue(const bool &_value) {
    return true;
}


const uint64_t& PlayerStubDefault::getCurrentTrackAttribute() {
    return currentTrackAttributeValue_;
}

const uint64_t& PlayerStubDefault::getCurrentTrackAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    return getCurrentTrackAttribute();
}

void PlayerStubDefault::setCurrentTrackAttribute(uint64_t _value) {
    const bool valueChanged = trySetCurrentTrackAttribute(std::move(_value));
    if (valueChanged && CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_ != NULL) {
         CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_->fireCurrentTrackAttributeChanged(currentTrackAttributeValue_);
     }
}

bool PlayerStubDefault::trySetCurrentTrackAttribute(uint64_t _value) {
    if (!validateCurrentTrackAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (currentTrackAttributeValue_ != _value);
    currentTrackAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool PlayerStubDefault::validateCurrentTrackAttributeRequestedValue(const uint64_t &_value) {
    return true;
}


const ::v1_0::org::genivi::mediamanager::PlayerTypes::PlaybackStatus& PlayerStubDefault::getPlaybackStatusAttribute() {
    return playbackStatusAttributeValue_;
}

const ::v1_0::org::genivi::mediamanager::PlayerTypes::PlaybackStatus& PlayerStubDefault::getPlaybackStatusAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    return getPlaybackStatusAttribute();
}

void PlayerStubDefault::setPlaybackStatusAttribute(::v1_0::org::genivi::mediamanager::PlayerTypes::PlaybackStatus _value) {
    const bool valueChanged = trySetPlaybackStatusAttribute(std::move(_value));
    if (valueChanged && CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_ != NULL) {
         CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_->firePlaybackStatusAttributeChanged(playbackStatusAttributeValue_);
     }
}

bool PlayerStubDefault::trySetPlaybackStatusAttribute(::v1_0::org::genivi::mediamanager::PlayerTypes::PlaybackStatus _value) {
    if (!validatePlaybackStatusAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (playbackStatusAttributeValue_ != _value);
    playbackStatusAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool PlayerStubDefault::validatePlaybackStatusAttributeRequestedValue(const ::v1_0::org::genivi::mediamanager::PlayerTypes::PlaybackStatus &_value) {
    return true;
}


const uint64_t& PlayerStubDefault::getPositionAttribute() {
    return positionAttributeValue_;
}

const uint64_t& PlayerStubDefault::getPositionAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    return getPositionAttribute();
}

void PlayerStubDefault::setPositionAttribute(uint64_t _value) {
    trySetPositionAttribute(std::move(_value));
}

bool PlayerStubDefault::trySetPositionAttribute(uint64_t _value) {
    if (!validatePositionAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (positionAttributeValue_ != _value);
    positionAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool PlayerStubDefault::validatePositionAttributeRequestedValue(const uint64_t &_value) {
    return true;
}


const uint64_t& PlayerStubDefault::getDurationAttribute() {
    return durationAttributeValue_;
}

const uint64_t& PlayerStubDefault::getDurationAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    return getDurationAttribute();
}

void PlayerStubDefault::setDurationAttribute(uint64_t _value) {
    const bool valueChanged = trySetDurationAttribute(std::move(_value));
    if (valueChanged && CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_ != NULL) {
         CommonAPI::Stub<PlayerStubAdapter, PlayerStubRemoteEvent>::stubAdapter_->fireDurationAttributeChanged(durationAttributeValue_);
     }
}

bool PlayerStubDefault::trySetDurationAttribute(uint64_t _value) {
    if (!validateDurationAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (durationAttributeValue_ != _value);
    durationAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool PlayerStubDefault::validateDurationAttributeRequestedValue(const uint64_t &_value) {
    return true;
}



/**
 * description: Skip to the next track in the play queue. If there is no
                      
 *   next track, playback is stopped. If playback is paused or
                    
 *     stopped, this function will set the next plack to be
                      
 *   played once playback is activated
 */
void PlayerStubDefault::next(const std::shared_ptr<CommonAPI::ClientId> _client, nextReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError e;
    _reply(e);
}

/**
 * description: Open the supplied Uri for playback in the playback engine.
         returns:
 *   INVALID_URI When an invalid URI is supplied
                              
 *   (decided by playback engine)
                   NO_ERROR    On success
 * param: uri URI of media to play, uri format is decided by backend
 */
void PlayerStubDefault::openUri(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _uri, openUriReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError e;
    _reply(e);
}

/**
 * description: Enqueue the supplied Uri for playback in the playback engine.
         returns:
 *   INVALID_URI When an invalid URI is supplied
                              
 *   (decided by playback engine)
                  NO_ERROR    On success
 * param: uri URI of media to enqueue, uri format is decided by backend
 */
void PlayerStubDefault::enqueueUri(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _uri, enqueueUriReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError e;
    _reply(e);
}

/**
 * description: Dequeue the item with the supplied index in the playback
                     
 *   engine.
 * param: pos index of media to dequeue
 */
void PlayerStubDefault::dequeueIndex(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t _pos, dequeueIndexReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError e;
    _reply(e);
}

/**
 * description: Retrieve the current play queue. The format of the result
                     
 *   object is described in MediaTypes.fidl
         returns: Current play queue
 */
void PlayerStubDefault::getCurrentPlayQueue(const std::shared_ptr<CommonAPI::ClientId> _client, getCurrentPlayQueueReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::MediaTypes::ResultMapList playQueue;
    ::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError e;
    _reply(playQueue, e);
}

/**
 * description: Dequeue all elements, emptying the play queue
 */
void PlayerStubDefault::dequeueAll(const std::shared_ptr<CommonAPI::ClientId> _client, dequeueAllReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError e;
    _reply(e);
}

/**
 * description: Use the supplied playlist as the current play queue. If
                     
 *   the play queue is invalid, the old play queue is
                     
 *   untouched.
         returns: BAD_PLAYLIST If playlist can not be loaded
      
 *               NO_ERROR     On success
 */
void PlayerStubDefault::openPlaylist(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _uri, openPlaylistReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError e;
    _reply(e);
}

/**
 * description: Pause playback in the playback engine.
                       If already
 *   paused, this has no effect
                       Note: If CanPause is false,
 *   this has no effect
 */
void PlayerStubDefault::pause(const std::shared_ptr<CommonAPI::ClientId> _client, pauseReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError e;
    _reply(e);
}

/**
 * description: Start or resume playback in the playback engine.
                       If
 *   playback is already commencing, this has not effect.
                       If
 *   paused, playback resumes from the current position.
                       If
 *   there is no track to play, calling this has no effect
                      
 *   Note: If CanPlay is false, this has no effect
 */
void PlayerStubDefault::play(const std::shared_ptr<CommonAPI::ClientId> _client, playReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError e;
    _reply(e);
}

/**
 * description: Starts playback (see Play) if paused
                      Pauses playback (see
 *   Pause) is playing
 * see: Play
 * see: Pause
 */
void PlayerStubDefault::playPause(const std::shared_ptr<CommonAPI::ClientId> _client, playPauseReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError e;
    _reply(e);
}

/**
 * description: Loads previous track in play queue
                      If there is no
 *   previous track, playback is stopped
                      If playback is
 *   stopped or paused, it remains this way,
                      but the next
 *   track to be played will the set
                      by this function
       
 *                 Note: If CanGoPrevious is false, this has no effect
 */
void PlayerStubDefault::previous(const std::shared_ptr<CommonAPI::ClientId> _client, previousReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError e;
    _reply(e);
}

/**
 * description: Seek relatively in the current track
                      If a negative seek
 *   leads to a play position less than 0,
                      the play position
 *   will be set to 0.
                      If a positive seek leads outside the
 *   length of the current
                      track, this is treated like a call
 *   to Next()
                      Note: If CanSeek is false, this has no effect
 * param: pos Relative seek amount in microseconds
 * see: Next
 */
void PlayerStubDefault::seek(const std::shared_ptr<CommonAPI::ClientId> _client, int64_t _pos, seekReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError e;
    _reply(e);
}

/**
 * description: Jump to the specified position in the current
                       If the
 *   position is not within range of the current track,
                       do
 *   nothing
         Note: If CanSeek is false, this has no effect
 * param: pos Absolute position in microseconds
 */
void PlayerStubDefault::setPosition(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t _pos, setPositionReply_t _reply) {
    ::v1_0::org::genivi::mediamanager::PlayerTypes::PlayerError e;
    _reply(e);
}




PlayerStubDefault::RemoteEventHandler::RemoteEventHandler(PlayerStubDefault *_defaultStub)
    : 
      defaultStub_(_defaultStub) {
}

} // namespace mediamanager
} // namespace genivi
} // namespace org
} // namespace v1_0
