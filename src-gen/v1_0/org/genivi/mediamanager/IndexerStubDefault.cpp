/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.3.v201507280808.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include <v1_0/org/genivi/mediamanager/IndexerStubDefault.hpp>
#include <assert.h>

namespace v1_0 {
namespace org {
namespace genivi {
namespace mediamanager {

IndexerStubDefault::IndexerStubDefault():
        remoteEventHandler_(this),
        interfaceVersion_(Indexer::getInterfaceVersion()) {
}

const CommonAPI::Version& IndexerStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> _client) {
    return interfaceVersion_;
}

IndexerStubRemoteEvent* IndexerStubDefault::initStubAdapter(const std::shared_ptr<IndexerStubAdapter> &_adapter) {
    CommonAPI::Stub<IndexerStubAdapter, IndexerStubRemoteEvent>::stubAdapter_ = _adapter;
    return &remoteEventHandler_;
}

const ::v1_0::org::genivi::mediamanager::Indexer::IndexerStatus& IndexerStubDefault::getIndexerStatusAttribute() {
    return indexerStatusAttributeValue_;
}

const ::v1_0::org::genivi::mediamanager::Indexer::IndexerStatus& IndexerStubDefault::getIndexerStatusAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    return getIndexerStatusAttribute();
}

void IndexerStubDefault::setIndexerStatusAttribute(::v1_0::org::genivi::mediamanager::Indexer::IndexerStatus _value) {
    const bool valueChanged = trySetIndexerStatusAttribute(std::move(_value));
    if (valueChanged && CommonAPI::Stub<IndexerStubAdapter, IndexerStubRemoteEvent>::stubAdapter_ != NULL) {
         CommonAPI::Stub<IndexerStubAdapter, IndexerStubRemoteEvent>::stubAdapter_->fireIndexerStatusAttributeChanged(indexerStatusAttributeValue_);
     }
}

bool IndexerStubDefault::trySetIndexerStatusAttribute(::v1_0::org::genivi::mediamanager::Indexer::IndexerStatus _value) {
    if (!validateIndexerStatusAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (indexerStatusAttributeValue_ != _value);
    indexerStatusAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool IndexerStubDefault::validateIndexerStatusAttributeRequestedValue(const ::v1_0::org::genivi::mediamanager::Indexer::IndexerStatus &_value) {
    return true;
}



/**
 * description: Get the path to the database file in the host file system.
                    
 *    This is the database file used by LMS to store metadata
 * param: output: Path to database file in host file system
 * deprecated: This is only used for testing purposes and will be removed
 */
void IndexerStubDefault::getDatabasePath(const std::shared_ptr<CommonAPI::ClientId> _client, getDatabasePathReply_t _reply) {
    std::string output = "";
    Indexer::IndexerError e;
    _reply(output, e);
}

/**
 * description: If the indexer is currently IDLE or RUNNING
                      (see
 *   IndexerStatus), stop indexing and set IndexerStatus
                      to
 *   STOPPED.
                      If indexer is currently STOPPED, no action is
 *   taken
 */
void IndexerStubDefault::stopIndexing(const std::shared_ptr<CommonAPI::ClientId> _client, stopIndexingReply_t _reply) {
    Indexer::IndexerError e;
    _reply(e);
}

/**
 * description: If indexer is currently STOPPED (see IndexerStatus),
                     
 *   status is changed to RUNNING and indexing is RUNNING. If
                     
 *   the status is IDLE or RUNNING, no action is taken.
                      Note
 *   that the status may go from RUNNING to IDLE directly
                     
 *   after issuing this call, if no files are to be indexed
 */
void IndexerStubDefault::startIndexing(const std::shared_ptr<CommonAPI::ClientId> _client, startIndexingReply_t _reply) {
    Indexer::IndexerError e;
    _reply(e);
}




IndexerStubDefault::RemoteEventHandler::RemoteEventHandler(IndexerStubDefault *_defaultStub)
    : 
      defaultStub_(_defaultStub) {
}

} // namespace mediamanager
} // namespace genivi
} // namespace org
} // namespace v1_0
